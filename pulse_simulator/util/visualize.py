import copy
import itertools
import numpy as np
import matplotlib.pyplot as plt
from sklearn.decomposition import PCA
from .operator import operator, state

def tomography_data(system, unitary, conditions):
    """extract the tomography data
    Args:
        system (System) : class for the target quantum system
        unitary (list) : list of the np.array of the target unitary matrices
        conditions (list) : measurement conditions to be extracted such as [(state0, observable0), ...]
    """
    data = {}
    for condition in conditions:
        ini = state(system, condition[0])
        obs = operator(system, condition[1]) 
        tmp = []
        for u in unitary:
            end = u@ini@u.T.conj()
            tmp.append(np.trace(obs@end))
        tmp = np.array(tmp).real
        data[str(condition)] = tmp
    return data
            
def hamiltonian_tomography_z_data(system, unitary, control):
    """extract the hamiltonian tomography (z) data
    Args:
        system (System) : class for the target quantum system
        unitary (list) : list of the np.array of the target unitary matrices
        control (int) : index of the control qubit be prepared 0 or 1 state
    """
    inis = [{control:"S0"}, {control:"S1"}]
    obss = []
    for idx, qubit in system.qubits.items():
        for obs in ["Ql","Qx","Qy","Qz"]:
            obss.append({idx:obs})
    conditions = list(itertools.product(inis, obss))
    data = tomography_data(system, unitary, conditions)
    
    shaped_data = {}
    for idx in system.qubits.keys():
        d0 = []
        d1 = []
        for obs in ["Ql","Qx","Qy","Qz"]:
            d0.append(data[str(({control:"S0"}, {idx:obs}))])
            d1.append(data[str(({control:"S1"}, {idx:obs}))])
        shaped_data[idx] = np.array([d0, d1])
    return shaped_data

def hamiltonian_tomography_x_data(system, unitary, control):
    """extract the hamiltonian tomography (x) data
    Args:
        system (System) : class for the target quantum system
        unitary (list) : list of the np.array of the target unitary matrices
        control (int) : index of the control qubit be prepared + or - state
    """
    inis = [{control:"Sp", "default":"Sp"}, {control:"Sm", "default":"Sp"}]
    obss = []
    for idx, qubit in system.qubits.items():
        for obs in ["Ql","Qx","Qy","Qz"]:
            obss.append({idx:obs})
    conditions = list(itertools.product(inis, obss))
    data = tomography_data(system, unitary, conditions)
    
    shaped_data = {}
    for idx in system.qubits.keys():
        d0 = []
        d1 = []
        for obs in ["Ql","Qx","Qy","Qz"]:
            d0.append(data[str(({control:"Sp", "default":"Sp"}, {idx:obs}))])
            d1.append(data[str(({control:"Sm", "default":"Sp"}, {idx:obs}))])
        shaped_data[idx] = np.array([d0, d1])
    return shaped_data

def visualize_hamiltonian_tomography(time, data, trig_pos=None):
    """visualize the results of the hamiltonian tomography
    Args:
        time (list or np.array) : simulation time
        data (np.array) : data generated by the function : hamiltonian_tomography_(z or x)_data
        trig_pos (np.array) : list of the trigger position list in the sequence_parser
    """
    for idx, tmp in data.items():
        print(f"Qubit ({idx})")
        plt.figure(figsize=(8,6))
        for i, label in enumerate(["Leak","X","Y","Z"]):
            plt.subplot(4,1,i+1)
            if trig_pos is not None:
                for pos in trig_pos:
                    plt.axvline(pos, color="red", linestyle="--")
            plt.plot(time, tmp[0][i])
            plt.plot(time, tmp[1][i])
            plt.ylabel(label)
            plt.xlim(time[0], time[-1])
            if label == "Leak":
                plt.yscale("log")
                plt.ylim(1e-5, 1)
            else:
                plt.axhline(-1, color="black", linestyle="--")
                plt.axhline(0, color="black", linestyle="--")
                plt.axhline(+1, color="black", linestyle="--")
            if label == "Z":
                plt.xlabel("Duration (ns)")
            else:
                plt.tick_params(labelbottom=False)
        plt.tight_layout()
        plt.show()
        
def _analyze_cr_vector(time, data):
    pca = PCA(n_components=2)
    proj = pca.fit_transform(data).T
    phase = np.unwrap(np.angle(proj[0] + 1j*proj[1]))
    norm = np.mean(np.gradient(phase)/np.gradient(time)/(2*np.pi))
    axis = np.cross(pca.components_[0], pca.components_[1])
    vector = norm * axis
    return vector

def _analyze_cr_pauli(time, data):
    v00 = _analyze_cr_vector(time, data[0].T)
    v10 = _analyze_cr_vector(time, data[1].T)
    vi  = 0.5*(v00 + v10)
    vz  = 0.5*(v00 - v10)
    pauli = np.pi*np.hstack([vi,vz])
    return pauli

def analyze_hamiltonian_tomography_z(time, data, idx):
    """analyze the results of the hamiltonian tomography (z)
    Args:
        time (list or np.array) : simulation time
        data (np.array) : data generated by the function : hamiltonian_tomography_z_data
        idx (int) : index of the qubit with the controlled rotation
    """
    tmp = data[idx]
    tmp = [tmp[0][1:], tmp[1][1:]]
    pauli = _analyze_cr_pauli(time, tmp)

    plt.figure(figsize=(8,2))
    plt.axhline(0, color="black", linestyle="--")
    plt.bar(range(6), pauli)
    plt.xticks(range(6), ["IX","IY","IZ","ZX","ZY","ZZ"])
    plt.xlabel("Pauli")
    plt.ylabel("Coefficients (MHz)")
    plt.show()
    
def analyze_hamiltonian_tomography_x(time, data, idx):
    """analyze the results of the hamiltonian tomography (x)
    Args:
        time (list or np.array) : simulation time
        data (np.array) : data generated by the function : hamiltonian_tomography_x_data
        idx (int) : index of the qubit with the controlled rotation
    """
    tmp = data[idx]
    tmp = [tmp[0][1:], tmp[1][1:]]
    pauli = _analyze_cr_pauli(time, tmp)

    plt.figure(figsize=(8,2))
    plt.axhline(0, color="black", linestyle="--")
    plt.bar(range(6), pauli)
    plt.xticks(range(6), ["XI","YI","ZI","XX","YX","ZX"])
    plt.xlabel("Pauli")
    plt.ylabel("Coefficients (MHz)")
    plt.show()
